Java虚拟机所管理的内存将会包括以下几个运行时数据区域：
1、程序计数器
    程序计数器占用的内存空间不大，里面记录了各线程当前字节码的行号。JVM的多线程是通过轮流执行CPU时间的方式实现，因此在一个线程离开自己的CPU切片时，需要记录当前的状态（字节码行号）。为了防止线程之间相互影响，每条线程都有自己独立的程序计数器，这类内存区域也被称为“线程私有”内存。例如在上图中，虚拟机栈、本地方法栈和程序计数器都属于“线程私有”内存。
    如果程序执行的是一个Java方法，程序计数器记录当前线程的字节码地址；如果执行的是一个本地方法，则程序计数器为空（undefined）。
    不会出现内存溢出的情况
2、Java虚拟机栈
    虚拟机栈可以看做是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
    局部变量表存放了编译期可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double）、对象引用和ruturnAddress类型。
    1.StackOverflowError
    2.OutOfMemory
3、本地方法栈
    虚拟机栈是为虚拟机执行的Java方法服务，而本地方法栈是为虚拟机使用到的Native方法服务；
    1.StackOverflowError
    2.OutOfMemory
4、Java堆
    Java堆唯一的目的就是存放对象实例，几乎所有的对象实例的都在这里分配内存；
    Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆；
    OutOfMemory
5、方法区
    方法区也是内存共享的一块区域，它用于存放已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据；
    方法区中还存在一个运行时常量池，常量池用于存放编译期生成的各种字面量和符号引用，它具有动态性，不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中；
    OutOfMemory
所有线程共享的是堆和方法区，其他都是线程私有的

static修饰的静态变量，生命周期一直持续到系统关闭

new Test();在堆中

Test test = new Test();  test在栈